<!-- Interactive Soundscape Generator, made by AI. -->
<!-- Standalone. Just open the html in your browser. -->
<!-- This was designed to assist in creating ambiences for Zones -->
<!-- The output is a config json of the type SoundscapeConfig -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ambient Synth & Soundscape Generator</title>
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #d4d4d4;
            --primary-color: #4a90e2;
            --secondary-color: #252526;
            --border-color: #333;
            --accent-color: #569cd6;
            --success-color: #4CAF50;
            --danger-color: #f44336;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 2rem; display: flex; justify-content: center; }
        .container { width: 100%; max-width: 900px; }
        h1, h2 { color: var(--primary-color); border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; }
        fieldset { background-color: var(--secondary-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; margin: 0 0 1.5rem 0; }
        legend { font-weight: bold; font-size: 1.2em; color: var(--accent-color); padding: 0 0.5rem; }
        .control-group { margin-bottom: 1rem; }
        .control-group label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
        .control-group .value-display { font-family: monospace; color: var(--accent-color); margin-left: 1rem; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 8px; border-radius: 4px; background: var(--border-color); outline: none; padding: 0; margin: 0; transition: opacity 0.2s; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 20px; height: 20px; border-radius: 50%; background: var(--primary-color); cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border-radius: 50%; background: var(--primary-color); cursor: pointer; }
        input[type="range"]:disabled { opacity: 0.4; }
        input[type="range"]:disabled::-webkit-slider-thumb, input[type="range"]:disabled::-moz-range-thumb { background: #666; cursor: not-allowed; }
        input, select, button, textarea { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 4px; padding: 0.5rem; font-size: 1em; box-sizing: border-box; }
        button { background-color: var(--primary-color); color: white; border: none; padding: 0.75rem 1.5rem; font-weight: bold; cursor: pointer; transition: background-color 0.2s; }
        button:hover { background-color: var(--accent-color); }
        .btn-add { width: 100%; margin-top: 1rem; background-color: #3a3d41;}
        .btn-add:hover { background-color: #4a4d51;}
        .btn-secondary { background-color: #3a3d41; }
        .btn-secondary:hover { background-color: #4a4d51;}
        .btn-copy.success { background-color: var(--success-color); }
        .play-button-container { text-align: center; margin-bottom: 2rem; }
        #play-pause-btn { width: 120px; height: 120px; font-size: 1.5rem; border-radius: 50%; }
        pre { background-color: #111; border: 1px solid var(--border-color); border-radius: 4px; padding: 1rem; white-space: pre-wrap; word-break: break-all; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; margin-top: 1rem; }
        .layer { border: 1px solid var(--border-color); border-radius: 8px; margin-bottom: 1.5rem; background-color: var(--secondary-color); }
        .layer > summary { font-size: 1.3em; font-weight: bold; padding: 1rem 1.5rem; cursor: pointer; position: relative; list-style: none; color: var(--accent-color); }
        .layer > summary::-webkit-details-marker { display: none; }
        .layer-controls { padding: 0 1.5rem 1.5rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; border-top: 1px dashed var(--border-color); padding-top: 1.5rem; }
        .filters-container { padding: 0 1.5rem 1.5rem; }
        .remove-btn { position: absolute; top: 50%; transform: translateY(-50%); right: 1.5rem; background-color: transparent; color: var(--danger-color); border: 1px solid var(--danger-color); border-radius: 4px; width: auto; height: auto; font-weight: bold; font-size: 0.8em; line-height: 1; padding: 0.4rem 0.6rem; }
        .remove-btn:hover { background-color: var(--danger-color); color: white; }
        .filter-block { position: relative; margin-bottom: 1.5rem; padding: 1rem 1.5rem 0.5rem; border: 1px dashed var(--border-color); border-radius: 8px; }
        .filter-block:last-child { margin-bottom: 0; }
        .lfo-group { border-left: 3px solid var(--accent-color); padding-left: 1rem; margin-top: 0.5rem; }
        .lfo-group label { font-size: 0.9em; opacity: 0.8; }
        .lfo-toggle { display: flex; align-items: center; gap: 0.5rem; }
        .source-controls { padding: 0 1.5rem 1.5rem; }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
        .modal-content { background-color: var(--secondary-color); margin: 15% auto; padding: 2rem; border: 1px solid var(--border-color); border-radius: 8px; width: 80%; max-width: 600px; }
        .modal-content textarea { width: 100%; height: 150px; resize: vertical; margin-bottom: 1rem; font-family: monospace; }
        .modal-actions { display: flex; gap: 1rem; justify-content: flex-end; }
    </style>
</head>
<body>

    <div class="container">
        <h1>Ambient Synth & Soundscape Generator</h1>
        <div class="play-button-container"><button id="play-pause-btn">Play</button></div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
            <fieldset>
                <legend>Global Settings</legend>
                <div class="control-group">
                    <label for="master-volume">Master Volume <span class="value-display" id="master-volume-value">0.25</span></label>
                    <input type="range" id="master-volume" min="0" max="1" step="0.01" value="0.25">
                </div>
            </fieldset>
            <fieldset>
                <legend>Config Actions</legend>
                <div style="display: flex; gap: 1rem;">
                    <button class="btn-copy" id="copy-config-btn" style="flex: 1;">Copy Config</button>
                    <button id="load-config-btn" class="btn-secondary" style="flex: 1;">Load Config</button>
                </div>
            </fieldset>
        </div>
        <pre id="config-output">{}</pre>
        <h2>Layers</h2>
        <div id="layers-container"></div>
        <button class="btn-add" id="add-layer-btn">Add Sound Layer</button>
    </div>

    <div id="load-config-modal" class="modal">
        <div class="modal-content">
            <h2>Load Configuration</h2>
            <p>Paste a previously copied configuration object into the text area below.</p>
            <textarea id="config-paste-area" placeholder="{ masterVolume: ..., layers: [ ... ] }"></textarea>
            <div class="modal-actions">
                <button id="paste-from-clipboard-btn" class="btn-secondary">Paste & Load from Clipboard</button>
                <button id="load-from-textarea-btn">Load</button>
                <button id="cancel-load-btn" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script type="module">
        const SimplexNoise = (() => { const F2 = 0.5 * (Math.sqrt(3.0) - 1.0), G2 = (3.0 - Math.sqrt(3.0)) / 6.0; const grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]]; const p = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180]; const perm = new Array(512); for (let i = 0; i < 512; i++) perm[i] = p[i & 255]; const dot = (g, x, y) => g[0] * x + g[1] * y; return { noise: function (xin, yin) { let n0, n1, n2; const s = (xin + yin) * F2; const i = Math.floor(xin + s), j = Math.floor(yin + s); const t = (i + j) * G2; const X0 = i - t, Y0 = j - t; const x0 = xin - X0, y0 = yin - Y0; let i1, j1; if (x0 > y0) { i1 = 1; j1 = 0; } else { i1 = 0; j1 = 1; } const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2; const x2 = x0 - 1.0 + 2.0 * G2, y2 = y0 - 1.0 + 2.0 * G2; const ii = i & 255, jj = j & 255; const gi0 = perm[ii + perm[jj]] % 12, gi1 = perm[ii + i1 + perm[jj + j1]] % 12, gi2 = perm[ii + 1 + perm[jj + 1]] % 12; let t0 = 0.5 - x0 * x0 - y0 * y0; if (t0 < 0) n0 = 0.0; else { t0 *= t0; n0 = t0 * t0 * dot(grad3[gi0], x0, y0); } let t1 = 0.5 - x1 * x1 - y1 * y1; if (t1 < 0) n1 = 0.0; else { t1 *= t1; n1 = t1 * t1 * dot(grad3[gi1], x1, y1); } let t2 = 0.5 - x2 * x2 - y2 * y2; if (t2 < 0) n2 = 0.0; else { t2 *= t2; n2 = t2 * t2 * dot(grad3[gi2], x2, y2); } return 70.0 * (n0 + n1 + n2); } }; })();
        
        const OSC_WAVEFORMS = ['sine', 'square', 'sawtooth', 'triangle'];
        const LFO_WAVEFORMS = ['sine', 'square', 'sawtooth', 'triangle', 'perlin'];
        const FILTER_TYPES = ["lowpass", "highpass", "bandpass", "lowshelf", "highshelf", "peaking", "notch", "allpass"];
        const TYPES_WITH_Q = ["lowpass", "highpass", "bandpass", "peaking", "notch", "allpass"];
        const TYPES_WITH_GAIN = ["lowshelf", "highshelf", "peaking"];
        
        let audioContext, masterGain, noiseSource, perlinNoiseBuffer = null, isPlaying = false;
        let audioGraph = { layers: {} };
        const dom = { playPauseBtn: document.getElementById('play-pause-btn'), masterVolume: document.getElementById('master-volume'), layersContainer: document.getElementById('layers-container'), addLayerBtn: document.getElementById('add-layer-btn'), copyConfigBtn: document.getElementById('copy-config-btn'), loadConfigBtn: document.getElementById('load-config-btn'), configOutput: document.getElementById('config-output'), loadConfigModal: document.getElementById('load-config-modal'), configPasteArea: document.getElementById('config-paste-area'), pasteFromClipboardBtn: document.getElementById('paste-from-clipboard-btn'), loadFromTextareaBtn: document.getElementById('load-from-textarea-btn'), cancelLoadBtn: document.getElementById('cancel-load-btn') };

        async function initAudioContext() { if (audioContext) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); masterGain = audioContext.createGain(); masterGain.connect(audioContext.destination); updateMasterVolume(); const bufferSize = 10 * audioContext.sampleRate; const noiseBuffer = audioContext.createBuffer(2, bufferSize, audioContext.sampleRate); for (let c = 0; c < 2; c++) { const output = noiseBuffer.getChannelData(c); for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1; } noiseSource = audioContext.createBufferSource(); noiseSource.buffer = noiseBuffer; noiseSource.loop = true; }
        function updateMasterVolume() { const value = parseFloat(dom.masterVolume.value); document.getElementById('master-volume-value').textContent = value.toFixed(2); if (masterGain) masterGain.gain.setTargetAtTime(value, audioContext.currentTime, 0.01); }
        function destroyAudioGraph() { Object.values(audioGraph.layers).forEach(layer => { layer.gain.disconnect(); if (layer.sourceNode && layer.sourceNode.stop) layer.sourceNode.stop(); if (layer.volumeLfo && layer.volumeLfo.source) layer.volumeLfo.source.stop(); Object.values(layer.oscLfos || {}).forEach(lfo => { if (lfo.source) lfo.source.stop(); }); Object.values(layer.filters).forEach(filter => { Object.values(filter.lfos).forEach(lfo => { if (lfo.source) lfo.source.stop(); }); }); }); audioGraph = { layers: {} }; }
        function createPerlinLFO(rate) { if (!perlinNoiseBuffer) { const duration = 30, sampleCount = audioContext.sampleRate * duration; perlinNoiseBuffer = audioContext.createBuffer(1, sampleCount, audioContext.sampleRate); const data = perlinNoiseBuffer.getChannelData(0); for (let i = 0; i < sampleCount; i++) data[i] = SimplexNoise.noise(i / 40000, 0); } const lfoSource = audioContext.createBufferSource(); lfoSource.buffer = perlinNoiseBuffer; lfoSource.loop = true; lfoSource.playbackRate.value = rate; lfoSource.start(); return lfoSource; }
        function createLFO(lfoState) { const lfoGain = audioContext.createGain(); lfoGain.gain.value = lfoState.depth; let lfoSource; if (lfoState.wave === 'perlin') { lfoSource = createPerlinLFO(lfoState.rate); } else { lfoSource = audioContext.createOscillator(); lfoSource.type = lfoState.wave; lfoSource.frequency.value = lfoState.rate; lfoSource.start(); } return { source: lfoSource, gain: lfoGain }; }
        function buildAudioGraph() { if (!audioContext || !noiseSource || !isPlaying) return; destroyAudioGraph(); dom.layersContainer.querySelectorAll('.layer').forEach(layerEl => { const layerId = layerEl.id; const layerState = readLayerState(layerEl); const layerGraph = { gain: audioContext.createGain(), filters: {}, sourceNode: null, oscLfos: {}, volumeLfo: null }; layerGraph.gain.gain.value = layerState.volume.base; if (layerState.volume.lfo) { const lfo = createLFO(layerState.volume.lfo); lfo.source.connect(lfo.gain).connect(layerGraph.gain.gain); layerGraph.volumeLfo = lfo; } let currentNode; if (layerState.source.type === 'noise') { currentNode = noiseSource; } else { const osc = audioContext.createOscillator(); osc.type = layerState.source.wave; osc.frequency.value = layerState.source.freq.base; osc.detune.value = layerState.source.detune.base; layerGraph.sourceNode = osc; ['freq', 'detune'].forEach(param => { const paramKey = param === 'freq' ? 'frequency' : param; const paramState = layerState.source[param]; if (paramState.lfo) { const lfo = createLFO(paramState.lfo); lfo.source.connect(lfo.gain).connect(osc[paramKey]); layerGraph.oscLfos[paramKey] = lfo; } }); osc.start(); currentNode = osc; } layerEl.querySelectorAll('.filter-block').forEach(filterEl => { const filterId = filterEl.id; const filterState = readFilterState(filterEl); const filterNode = audioContext.createBiquadFilter(); filterNode.type = filterState.type; filterNode.frequency.value = filterState.frequency.base; filterNode.Q.value = filterState.Q.base; filterNode.gain.value = filterState.gain.base; const filterGraph = { node: filterNode, lfos: {} }; ['frequency', 'Q', 'gain'].forEach(param => { const paramState = filterState[param]; if (paramState.lfo) { const lfo = createLFO(paramState.lfo); lfo.source.connect(lfo.gain).connect(filterNode[param]); filterGraph.lfos[param] = lfo; } }); currentNode.connect(filterNode); currentNode = filterNode; layerGraph.filters[filterId] = filterGraph; }); currentNode.connect(layerGraph.gain).connect(masterGain); audioGraph.layers[layerId] = layerGraph; }); updateConfigOutput(); }
        function getDescendantProp(obj, desc) { const arr = desc.split('.'); while(arr.length && obj) obj = obj[arr.shift()]; return obj; }
        function updateAudioParameter(path, value) { if (!isPlaying || !audioContext) return; const finalDotIndex = path.lastIndexOf('.'); const parentPath = path.substring(0, finalDotIndex), propName = path.substring(finalDotIndex + 1); const parentObject = getDescendantProp(audioGraph, parentPath); if (parentObject && typeof parentObject[propName] !== 'undefined') { const target = parentObject[propName]; if (target instanceof AudioParam) target.setTargetAtTime(value, audioContext.currentTime, 0.02); else parentObject[propName] = value; } }
        function readLayerState(layerEl) { const sourceType = layerEl.querySelector(`[name="source-type-${layerEl.id}"]:checked`).value; const sourceConfig = { type: sourceType }; if (sourceType === 'oscillator') { sourceConfig.wave = layerEl.querySelector('[data-prop="osc-wave"]')?.value; sourceConfig.freq = readModulatedParam(layerEl.querySelector('.osc-freq-controls')); sourceConfig.detune = readModulatedParam(layerEl.querySelector('.osc-detune-controls')); } return { volume: readModulatedParam(layerEl.querySelector('.volume-controls')), source: sourceConfig, }; }
        function readFilterState(filterEl) { return { type: filterEl.querySelector('[data-prop="type"]').value, frequency: readModulatedParam(filterEl.querySelector('.frequency-controls')), Q: readModulatedParam(filterEl.querySelector('.q-controls')), gain: readModulatedParam(filterEl.querySelector('.gain-controls')) }; }
        function readModulatedParam(container) { const result = { base: parseFloat(container.querySelector('[data-prop="base"]').value) }; const lfoEnabled = container.querySelector('[data-lfo-prop="enabled"]')?.checked ?? false; if (lfoEnabled) { result.lfo = { wave: container.querySelector('[data-lfo-prop="wave"]')?.value ?? 'sine', rate: parseFloat(container.querySelector('[data-lfo-prop="rate"]')?.value ?? 0), depth: parseFloat(container.querySelector('[data-lfo-prop="depth"]')?.value ?? 0) }; } return result; }
        function readFullConfig() { const config = { masterVolume: parseFloat(dom.masterVolume.value), layers: [] }; dom.layersContainer.querySelectorAll('.layer').forEach(layerEl => { const layerConfig = readLayerState(layerEl); layerConfig.filters = []; layerEl.querySelectorAll('.filter-block').forEach(filterEl => layerConfig.filters.push(readFilterState(filterEl))); config.layers.push(layerConfig); }); return config; }
        function updateConfigOutput() { const config = readFullConfig(); const jsonString = JSON.stringify(config, (k, v) => typeof v === 'number' ? parseFloat(v.toFixed(4)) : v, 2); dom.configOutput.textContent = jsonString.replace(/"([^"]+)":/g, '$1:'); }
        function createModulationControls(rate, depth) { const id = `lfo-enabled-${Math.random().toString(36).substr(2, 9)}`; return `<div class="lfo-group"><div class="lfo-toggle"><input type="checkbox" data-lfo-prop="enabled" id="${id}"><label for="${id}">Enable LFO</label></div><div class="lfo-params" style="display: none;"><label>Wave</label><select data-lfo-prop="wave">${LFO_WAVEFORMS.map(w => `<option value="${w}">${w}</option>`).join('')}</select><label>Rate <span class="value-display">${rate.val.toFixed(2)}</span></label><input type="range" min="${rate.min}" max="${rate.max}" step="${rate.step}" value="${rate.val}" data-lfo-prop="rate"><label>Depth <span class="value-display">${depth.val.toFixed(3)}</span></label><input type="range" min="${depth.min}" max="${depth.max}" step="${depth.step}" value="${depth.val}" data-lfo-prop="depth"></div></div>`; }
        function createFilterBlock() { const block = document.createElement('div'); block.className = 'filter-block'; block.id = `filter-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`; block.innerHTML = `<button class="remove-btn" title="Remove Filter" style="top: 1rem; right: 1rem;">&times;</button><div class="control-group"><label>Type</label><select data-prop="type">${FILTER_TYPES.map(t=>`<option value="${t}" ${t==='lowpass'?'selected':''}>${t}</option>`).join('')}</select></div><div class="control-group frequency-controls"><label>Frequency <span class="value-display">1000 Hz</span></label><input type="range" min="20" max="20000" step="1" value="1000" data-prop="base">${createModulationControls({min:0.01,max:20,step:0.01,val:0.5},{min:0,max:5000,step:1,val:400})}</div><div class="control-group q-controls"><label>Q <span class="value-display">1</span></label><input type="range" min="0.0001" max="30" step="0.01" value="1" data-prop="base">${createModulationControls({min:0.01,max:10,step:0.01,val:0.3},{min:0,max:15,step:0.001,val:4})}</div><div class="control-group gain-controls"><label>Gain <span class="value-display">0 dB</span></label><input type="range" min="-40" max="40" step="0.1" value="0" data-prop="base" disabled>${createModulationControls({min:0.01,max:5,step:0.01,val:0.2},{min:0,max:20,step:0.01,val:10})}</div>`; return block; }
        function createLayerBlock() {
            const layerId = `layer-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
            const layer = document.createElement('details'); layer.className = 'layer'; layer.id = layerId; layer.open = true;
            layer.innerHTML = `<summary>Sound Layer<button class="remove-btn" title="Remove Layer">Remove Layer</button></summary><div class="source-controls"><fieldset><legend>Source</legend><div style="display: flex; gap: 2rem; margin-bottom: 1rem;"><label><input type="radio" name="source-type-${layerId}" value="noise" checked> Noise</label><label><input type="radio" name="source-type-${layerId}" value="oscillator"> Oscillator</label></div><div class="osc-params" style="display: none;"><div class="control-group"><label>Waveform</label><select data-prop="osc-wave">${OSC_WAVEFORMS.map(w => `<option value="${w}">${w}</option>`).join('')}</select></div><div class="control-group osc-freq-controls"><label>Frequency <span class="value-display">440 Hz</span></label><input type="range" min="20" max="2000" step="1" value="440" data-prop="base">${createModulationControls({min:0.01,max:20,step:0.01,val:5},{min:0,max:100,step:1,val:10})}</div><div class="control-group osc-detune-controls"><label>Detune (Cents) <span class="value-display">0</span></label><input type="range" min="-1200" max="1200" step="1" value="0" data-prop="base">${createModulationControls({min:0.01,max:10,step:0.01,val:1},{min:0,max:100,step:1,val:25})}</div></div></fieldset></div><div class="layer-controls"><div class="control-group volume-controls"><label>Volume <span class="value-display">0.500</span></label><input type="range" min="0" max="1" step="0.001" value="0.5" data-prop="base">${createModulationControls({min:0.01,max:10,step:0.01,val:0.2},{min:0,max:0.5,step:0.001,val:0.25})}</div></div><div class="filters-container"></div><div style="padding: 0 1.5rem 1.5rem;"><button class="btn-add btn-add-filter">Add Filter</button></div>`;
            return layer;
        }
        
        function attachLayerEventListeners(layerEl) { const layerId = layerEl.id; layerEl.querySelector('.remove-btn').addEventListener('click', e => { e.preventDefault(); layerEl.remove(); rebuildGraphAndConfig(); }); layerEl.querySelector('.btn-add-filter').addEventListener('click', () => { const filterContainer = layerEl.querySelector('.filters-container'), newFilterBlock = createFilterBlock(); filterContainer.appendChild(newFilterBlock); attachFilterEventListeners(newFilterBlock); rebuildGraphAndConfig(); }); const oscParamsDiv = layerEl.querySelector('.osc-params'); layerEl.querySelectorAll(`[name="source-type-${layerId}"]`).forEach(radio => { radio.addEventListener('change', () => { oscParamsDiv.style.display = radio.value === 'oscillator' ? 'block' : 'none'; rebuildGraphAndConfig(); }); }); layerEl.querySelector('[data-prop="osc-wave"]').addEventListener('change', e => { updateAudioParameter(`layers.${layerId}.sourceNode.type`, e.target.value); updateConfigOutput(); }); const basePath = `layers.${layerId}`; attachModParamListeners(layerEl.querySelector('.volume-controls'), basePath, v => v.toFixed(3), { base: 'gain.gain.value', rate: 'volumeLfo.source', depth: 'volumeLfo.gain.gain.value' }); attachModParamListeners(layerEl.querySelector('.osc-freq-controls'), basePath, v => `${Math.round(v)} Hz`, { base: 'sourceNode.frequency.value', rate: 'oscLfos.frequency.source', depth: 'oscLfos.frequency.gain.gain.value' }); attachModParamListeners(layerEl.querySelector('.osc-detune-controls'), basePath, v => v, { base: 'sourceNode.detune.value', rate: 'oscLfos.detune.source', depth: 'oscLfos.detune.gain.gain.value' }); }
        function attachFilterEventListeners(filterEl) { const layerId = filterEl.closest('.layer').id; filterEl.querySelector('.remove-btn').addEventListener('click', () => { filterEl.remove(); rebuildGraphAndConfig(); }); const typeSelect = filterEl.querySelector('[data-prop="type"]'); typeSelect.addEventListener('change', () => { filterEl.querySelector('.q-controls [data-prop="base"]').disabled = !TYPES_WITH_Q.includes(typeSelect.value); filterEl.querySelector('.gain-controls [data-prop="base"]').disabled = !TYPES_WITH_GAIN.includes(typeSelect.value); rebuildGraphAndConfig(); }); const basePath = `layers.${layerId}.filters.${filterEl.id}`; attachModParamListeners(filterEl.querySelector('.frequency-controls'), basePath, v => `${Math.round(v)} Hz`, { base: 'node.frequency.value', rate: 'lfos.frequency.source', depth: 'lfos.frequency.gain.gain.value' }); attachModParamListeners(filterEl.querySelector('.q-controls'), basePath, v => v.toFixed(3), { base: 'node.Q.value', rate: 'lfos.Q.source', depth: 'lfos.Q.gain.gain.value' }); attachModParamListeners(filterEl.querySelector('.gain-controls'), basePath, v => v.toFixed(1), { base: 'node.gain.value', rate: 'lfos.gain.source', depth: 'lfos.gain.gain.value' }); }
        function attachModParamListeners(container, basePath, displayFormatter, pathMap) { container.querySelector('[data-prop="base"]').addEventListener('input', e => { const value = parseFloat(e.target.value); e.target.previousElementSibling.querySelector('.value-display').textContent = displayFormatter(value); updateAudioParameter(`${basePath}.${pathMap.base}`, value); updateConfigOutput(); }); const lfoToggle = container.querySelector('[data-lfo-prop="enabled"]'), lfoParams = container.querySelector('.lfo-params'); lfoToggle.addEventListener('change', () => { lfoParams.style.display = lfoToggle.checked ? 'block' : 'none'; rebuildGraphAndConfig(); }); const waveSelect = lfoParams.querySelector('[data-lfo-prop="wave"]'), rateSlider = lfoParams.querySelector('[data-lfo-prop="rate"]'); waveSelect.addEventListener('change', () => { const isPerlin = waveSelect.value === 'perlin'; rateSlider.min = isPerlin ? 0.01 : 0.1; rateSlider.max = isPerlin ? 5 : 20; rateSlider.step = isPerlin ? 0.01 : 0.1; rebuildGraphAndConfig(); }); rateSlider.addEventListener('input', e => { const value = parseFloat(e.target.value); const isPerlin = waveSelect.value === 'perlin'; e.target.previousElementSibling.querySelector('.value-display').textContent = `${value.toFixed(2)}${isPerlin ? 'x' : ' Hz'}`; const rateProp = isPerlin ? 'playbackRate.value' : 'frequency.value'; updateAudioParameter(`${basePath}.${pathMap.rate}.${rateProp}`, value); updateConfigOutput(); }); lfoParams.querySelector('[data-lfo-prop="depth"]').addEventListener('input', e => { const value = parseFloat(e.target.value); e.target.previousElementSibling.querySelector('.value-display').textContent = value.toFixed(3); updateAudioParameter(`${basePath}.${pathMap.depth}`, value); updateConfigOutput(); }); }
        function rebuildGraphAndConfig() { if (isPlaying) buildAudioGraph(); updateConfigOutput(); }
        function populateModulatedParam(container, config) { if (!config) return; const baseSlider = container.querySelector('[data-prop="base"]'); baseSlider.value = config.base; baseSlider.dispatchEvent(new Event('input')); if (config.lfo) { const lfoToggle = container.querySelector('[data-lfo-prop="enabled"]'); lfoToggle.checked = true; const lfoParams = container.querySelector('.lfo-params'); lfoParams.style.display = 'block'; const waveSelect = lfoParams.querySelector('[data-lfo-prop="wave"]'); waveSelect.value = config.lfo.wave; waveSelect.dispatchEvent(new Event('change')); const rateSlider = lfoParams.querySelector('[data-lfo-prop="rate"]'); rateSlider.value = config.lfo.rate; rateSlider.dispatchEvent(new Event('input')); const depthSlider = lfoParams.querySelector('[data-lfo-prop="depth"]'); depthSlider.value = config.lfo.depth; depthSlider.dispatchEvent(new Event('input')); } }
        function loadConfig(configString) { let config; try { config = new Function(`return (${configString})`)(); if (typeof config.masterVolume !== 'number' || !Array.isArray(config.layers)) throw new Error("Invalid config structure."); } catch (e) { alert(`Error parsing configuration:\n${e.message}`); return; } dom.layersContainer.innerHTML = ''; dom.masterVolume.value = config.masterVolume; dom.masterVolume.dispatchEvent(new Event('input')); config.layers.forEach(layerConfig => { const layerBlock = createLayerBlock(); populateModulatedParam(layerBlock.querySelector('.volume-controls'), layerConfig.volume); const sourceTypeRadio = layerBlock.querySelector(`[name^="source-type-"][value="${layerConfig.source.type}"]`); if(sourceTypeRadio) sourceTypeRadio.checked = true; layerBlock.querySelector('.osc-params').style.display = layerConfig.source.type === 'oscillator' ? 'block' : 'none'; if (layerConfig.source.type === 'oscillator') { layerBlock.querySelector('[data-prop="osc-wave"]').value = layerConfig.source.wave; populateModulatedParam(layerBlock.querySelector('.osc-freq-controls'), layerConfig.source.freq); populateModulatedParam(layerBlock.querySelector('.osc-detune-controls'), layerConfig.source.detune); } const filterContainer = layerBlock.querySelector('.filters-container'); if(layerConfig.filters) { layerConfig.filters.forEach(filterConfig => { const filterBlock = createFilterBlock(); const typeSelect = filterBlock.querySelector('[data-prop="type"]'); typeSelect.value = filterConfig.type; populateModulatedParam(filterBlock.querySelector('.frequency-controls'), filterConfig.frequency); populateModulatedParam(filterBlock.querySelector('.q-controls'), filterConfig.Q); populateModulatedParam(filterBlock.querySelector('.gain-controls'), filterConfig.gain); filterContainer.appendChild(filterBlock); attachFilterEventListeners(filterBlock); }); } dom.layersContainer.appendChild(layerBlock); attachLayerEventListeners(layerBlock); }); rebuildGraphAndConfig(); }
        function togglePlayState() { initAudioContext().then(() => { if (audioContext.state === 'suspended') audioContext.resume(); isPlaying = !isPlaying; if (isPlaying) { dom.playPauseBtn.textContent = 'Pause'; noiseSource.start(0); rebuildGraphAndConfig(); } else { dom.playPauseBtn.textContent = 'Play'; destroyAudioGraph(); const oldBuffer = noiseSource.buffer; noiseSource.disconnect(); noiseSource = audioContext.createBufferSource(); noiseSource.buffer = oldBuffer; noiseSource.loop = true; } }); }
        dom.playPauseBtn.addEventListener('click', togglePlayState);
        dom.masterVolume.addEventListener('input', updateMasterVolume);
        dom.addLayerBtn.addEventListener('click', () => { const newLayerBlock = createLayerBlock(); dom.layersContainer.appendChild(newLayerBlock); attachLayerEventListeners(newLayerBlock); const filterContainer = newLayerBlock.querySelector('.filters-container'); const newFilterBlock = createFilterBlock(); filterContainer.appendChild(newFilterBlock); attachFilterEventListeners(newFilterBlock); rebuildGraphAndConfig(); });
        dom.copyConfigBtn.addEventListener('click', () => navigator.clipboard.writeText(dom.configOutput.textContent).then(() => { dom.copyConfigBtn.textContent = 'Copied!'; dom.copyConfigBtn.classList.add('success'); setTimeout(() => { dom.copyConfigBtn.textContent = 'Copy Config'; dom.copyConfigBtn.classList.remove('success'); }, 1500); }));
        dom.loadConfigBtn.addEventListener('click', () => { dom.loadConfigModal.style.display = 'block'; });
        dom.cancelLoadBtn.addEventListener('click', () => { dom.loadConfigModal.style.display = 'none'; });
        dom.loadFromTextareaBtn.addEventListener('click', () => { loadConfig(dom.configPasteArea.value); dom.loadConfigModal.style.display = 'none'; });
        dom.pasteFromClipboardBtn.addEventListener('click', () => { if (navigator.clipboard && navigator.clipboard.readText) { navigator.clipboard.readText().then(text => { dom.configPasteArea.value = text; loadConfig(text); dom.loadConfigModal.style.display = 'none'; }).catch(err => alert('Failed to read clipboard contents: ' + err)); } else { alert('Clipboard API not available in this browser.'); } });

        dom.addLayerBtn.click();
    </script>
</body>
</html>