// This module keeps track of the data of the engine game we are currently in.

import type { Player } from '../../../../../shared/chess/util/typeutil.js';

import selection from '../chess/selection.js';
import checkmatepractice from '../chess/checkmatepractice.js';
import gameslot from '../chess/gameslot.js';
import movesequence from '../chess/movesequence.js';
import gamecompressor from '../chess/gamecompressor.js';
import jsutil from '../../../../../shared/util/jsutil.js';
import typeutil, { players } from '../../../../../shared/chess/util/typeutil.js';
import { animateMove } from '../chess/graphicalchanges.js';
import premoves from '../chess/premoves.js';
import perspective from '../rendering/perspective.js';
import movevalidation from '../../../../../shared/chess/logic/movevalidation.js';
import coordutil, { Coords, CoordsKey } from '../../../../../shared/chess/util/coordutil.js';
import boardpos from '../rendering/boardpos.js';
import snapping from '../rendering/highlights/snapping.js';
import squarerendering from '../rendering/highlights/squarerendering.js';
import drawsquares from '../rendering/highlights/annotations/drawsquares.js';
import frametracker from '../rendering/frametracker.js';
// @ts-ignore
import statustext from '../gui/statustext.js';

// Type Definitions -------------------------------------------------------------

/** List of valid engines */
type validEngineName = 'engineCheckmatePractice' | 'hydrochess'; // Add more union types when more engines are added

interface EngineConfig {
	/** Hard time limit for the engine to think in milliseconds */
	engineTimeLimitPerMoveMillis: number;
	// If you are using a checkmate practice engine, this is required.
	checkmateSelectedID?: string;
	strengthLevel?: number;
	multiPv?: number;
}

// Constants --------------------------------------------------------------------

/**
 * World border config for each individual engine.
 * Engine games have a world border enabled so as to keep the position within safe floating point range.
 * If the variant's world border is smaller, that will be used instead.
 */
const engineWorldBorderDict: { [key in validEngineName]: bigint } = {
	// engineCheckmatePractice: BigInt(Number.MAX_SAFE_INTEGER), // FREEZES practice checkmate engine if you move to the border
	engineCheckmatePractice: BigInt(1e15), // 1 Quadrillion (~11% the distance of Number.MAX_SAFE_INTEGER)
	hydrochess: BigInt(1e15),
};

/**
 * Default engine think time config.
 * This is the number of milliseconds that each engine thinks when Time Control is unlimited.
 * May vary from engine to engine because of different engine speeds and requirements.
 */
const engineDefaultTimeLimitPerMoveMillisDict: { [key in validEngineName]: number } = {
	engineCheckmatePractice: 500,
	hydrochess: 4000,
};

// Variables --------------------------------------------------------------------

/** Whether we are currently in an engine game. */
let inEngineGame: boolean = false;
let ourColor: Player | undefined;
let engineColor: Player | undefined;
let currentEngine: string | undefined; // name of the current engine used
let engineConfig: EngineConfig | undefined; // json that is sent to the engine, giving it extra config information
let engineWorker: Worker | undefined;

/** Whether to render the engine's generated legal moves for debugging purposes. Toggled by pressing `7`. */
let move_gen_debug: boolean = false;
/** Stores the legal moves generated by the engine for each move index in the game history. */
const moveHistoryLegalMoves: Map<number, string[]> = new Map();

// Functions ------------------------------------------------------------------------

function areInEngineGame(): boolean {
	return inEngineGame;
}

function getOurColor(): Player | undefined {
	if (!inEngineGame) throw Error('Cannot get our color if we are not in an engine game!');
	return ourColor!;
}

function isItOurTurn(): boolean {
	if (!inEngineGame)
		throw Error("Cannot get isItOurTurn of engine game when we're not in an engine game.");
	return gameslot.getGamefile()!.basegame.whosTurn === ourColor;
}

function getCurrentEngine(): string | undefined {
	return currentEngine;
}

/**
 * Inits an engine game. In particular, it needs gameOptions in order to know what engine to use for this enginegame.
 * This method launches an engine webworker for the current game.
 * @param {Object} options - An object that contains the properties `currentEngine` and `engineConfig`
 */
function initEngineGame(options: {
	youAreColor: Player;
	currentEngine: string;
	engineConfig: EngineConfig;
}): Promise<void> {
	console.log(`Starting engine game with engine "${options.currentEngine}".`);

	inEngineGame = true;
	ourColor = options.youAreColor;
	engineColor = typeutil.invertPlayer(ourColor);
	currentEngine = options.currentEngine;
	engineConfig = options.engineConfig;

	// Initialize the engine as a webworker
	if (!window.Worker) {
		alert("Your browser doesn't support web workers. Cannot play against an engine.");
		// Reject the promise returned by this function
		return Promise.reject(
			new Error("Cannot finish loading engine game because web workers aren't supported."),
		);
	}
	engineWorker = new Worker(`../scripts/esm/game/chess/engines/${currentEngine}.js`, {
		type: 'module',
	}); // module type allows the web worker to import methods and types from other scripts.

	// Return a promise that resolves when the ENGINE WORKER has finished fetching/loading.
	return new Promise<void>((resolve, reject): void => {
		// Set up a handler for the 'isready' command that indicates the worker is loaded and ready
		// We have to manually send this message at the top of our engines.
		engineWorker!.onmessage = (e: MessageEvent): void => {
			if (e.data === 'readyok') resolve(); // Engine is ready!
		};
		engineWorker!.onerror = (e: ErrorEvent): void => {
			reject(new Error('Worker failed to load: ' + e.message));
		};
	}).then((_result: any) => {
		// After the promise resolves, we know the worker is ready
		// Overwrite the onmessage listener to listen for move submissions
		engineWorker!.onmessage = (e: MessageEvent): void => handleEngineMessage(e.data);
		// Remove the error handler (no longer needed after worker is ready)
		engineWorker!.onerror = null;
		// Ensures if the debug mode was on before starting an engine game,
		// the engine generated legal moves are rendered as soon as the engine is ready.
		if (move_gen_debug) sendPositionToEngine(true);
	});
}

// Call when we leave an engine game
function closeEngineGame(): void {
	inEngineGame = false;
	ourColor = undefined;
	engineColor = undefined;
	currentEngine = undefined;
	engineConfig = undefined;
	moveHistoryLegalMoves.clear();
	perspective.resetRotations(); // Without this, leaving an engine game of which we were black, won't reset our rotation.

	// terminate the webworker
	if (engineWorker) engineWorker.terminate();
	engineWorker = undefined;
	checkmatepractice.onGameUnload();
}

/**
 * Tests if we are this color in the engine game.
 * @param color - p.WHITE / p.BLACK
 * @returns *true* if we are that color.
 */
function areWeColor(color: Player): boolean {
	return color === ourColor;
}

/**
 * This method is called externally when the player submits his move in an engine game
 * It submits the gamefile to the webworker
 */
function onMovePlayed(): void {
	if (!inEngineGame) return; // Don't do anything if it's not an engine game
	const gamefile = gameslot.getGamefile()!;
	// Make sure it's the engine's turn
	if (gamefile.basegame.whosTurn !== engineColor) return; // Don't do anything if it's our turn (not the engines)
	checkmatepractice.registerHumanMove(); // inform the checkmatepractice script that the human player has made a move
	if (gamefile.basegame.gameConclusion) return; // Don't do anything if the game is over

	if (move_gen_debug) sendPositionToEngine(true); // Request generated moves for debugging FIRST (doesn't perform best move calculation)
	sendPositionToEngine(false); // Perform normal best move calculation
}

/**
 * Sends the current position to the engine web worker.
 * If the {@link requestGeneratedMoves} flag is false, then the engine should perform a best move calculation.
 * Else it should send us the list of generated legal moves for debugging purposes.
 */
function sendPositionToEngine(requestGeneratedMoves: boolean): void {
	if (!inEngineGame) return;
	const gamefile = gameslot.getGamefile()!;
	const longformIn = gamecompressor.compressGamefile(gamefile); // Compress the gamefile to send to the engine in a simpler json format
	// Send the gamefile to the engine web worker
	/** This has all nested functions removed. */
	const stringGamefile = JSON.stringify(gamefile, jsutil.stringifyReplacer);

	// Derive clock times for both colors in milliseconds, similar to UCI wtime/btime/winc/binc
	let wtime: number | undefined;
	let btime: number | undefined;
	let winc: number | undefined;
	let binc: number | undefined;
	const basegame = gamefile.basegame;
	const clocks = basegame.clocks;
	if (!basegame.untimed && clocks) {
		wtime = clocks.currentTime[players.WHITE];
		btime = clocks.currentTime[players.BLACK];
		const incSeconds = clocks.startTime.increment;
		winc = incSeconds * 1000;
		binc = incSeconds * 1000;
	}

	// prettier-ignore
	const timing = wtime !== undefined && btime !== undefined ? {
		wtime,
		btime,
		winc,
		binc,
	} : undefined;

	if (engineWorker)
		engineWorker.postMessage({
			stringGamefile,
			lf: longformIn,
			engineConfig: engineConfig,
			youAreColor: engineColor,
			wtime: timing?.wtime,
			btime: timing?.btime,
			winc: timing?.winc,
			binc: timing?.binc,
			requestGeneratedMoves,
		});
	else console.error('User made a move in an engine game but no engine webworker is loaded!');
}

function handleEngineMessage(data: any): void {
	if (typeof data !== 'object' || data === null) {
		console.error('Received invalid message from engine worker:', data);
		return;
	}

	// Check if the message contains generated moves for debugging
	if (data.type === 'move') {
		// Message contains the engine's best move suggestion
		makeEngineMove(data.data);
	} else if (data.type === 'generatedMoves') {
		// Always store the moves at the latest ply (front of the game)
		const gamefile = gameslot.getGamefile()!;
		const latestMoveIndex = gamefile.boardsim.moves.length - 1;
		moveHistoryLegalMoves.set(latestMoveIndex, [...data.data]);
		// console.log('Received generated moves from engine worker:', data.data);
		frametracker.onVisualChange(); // Ensure the frame is rendered
	} else {
		console.error('Received unknown message from engine worker:', data);
	}
}

/**
 * This method takes care of all the logic involved in making an engine move
 * It gets called after the engine finishes its calculation
 * @param move - The move that SHOULD be a string in compact format "x,y>x,y=P"
 */
function makeEngineMove(compactMove: unknown): void {
	if (!inEngineGame) return;
	if (!currentEngine)
		return console.error('Attempting to make engine move, but no engine loaded!');

	const gamefile = gameslot.getGamefile()!;
	const mesh = gameslot.getMesh();

	// Rewind all premoves to get the real game state before making any other board changes
	premoves.rewindPremoves(gamefile, mesh);

	const moveValidationResults = movevalidation.isEnginesMoveLegal(gamefile, compactMove);

	if (!moveValidationResults.valid) {
		statustext.showStatus(
			`Engine submitted an illegal move. Please report this bug!`,
			true,
			100,
		);
		console.error(
			`Engine move "${compactMove}" is illegal for reason: ${moveValidationResults.reason}`,
		);
		// Don't forget to reapply premoves before exiting
		premoves.applyPremoves(gamefile, mesh);
		return;
	}

	// Go to latest move before making a new move
	movesequence.viewFront(gamefile, mesh);
	/**
	 * PERHAPS we don't need this stuff? It's just to find and apply any special move flag
	 * that should go with the move. But shouldn't the engine provide that info with its move?
	 */
	// const piecemoved = gamefileutility.getPieceAtCoords(gamefile, move.startCoords)!;
	// const legalMoves = legalmoves.calculateAll(gamefile, piecemoved)
	// const endCoordsToAppendSpecial: CoordsSpecial = jsutil.deepCopyObject(move.endCoords);
	// legalmoves.checkIfMoveLegal(legalMoves, move.startCoords, endCoordsToAppendSpecial); // Passes on any special moves flags to the endCoords

	const move = movesequence.makeMove(gamefile, mesh, moveValidationResults.draft);
	if (mesh) animateMove(move.changes, true, true); // ONLY ANIMATE if the mesh has been generated. This may happen if the engine moves extremely fast on turn 1.

	// We should probably have this last, since this will make another move AFTER handling our engine's move here.
	// And it'd be weird to process that move before this engine's move is fully processed.
	premoves.onYourMove(gamefile, mesh);

	selection.reselectPiece(); // Reselect the currently selected piece. Recalc its moves and recolor it if needed.

	checkmatepractice.registerEngineMove(); // inform the checkmatepractice script that the engine has made a move

	// If the debug mode is on, request the generated moves for the new position after playing the engine's move
	if (move_gen_debug) sendPositionToEngine(true);
}

function onGameConclude(): void {
	if (!inEngineGame) return;
	checkmatepractice.onEngineGameConclude();
}

/** Toggles the rendering of engine generated legal moves for debugging purposes. */
function toggleDebug(): void {
	move_gen_debug = !move_gen_debug;
	statustext.showStatus(`Toggled engine move gen highlights: ${move_gen_debug}`);

	if (move_gen_debug && inEngineGame) {
		// If no moves are cached for the latest ply, request them
		const gamefile = gameslot.getGamefile();
		if (gamefile) {
			const latestMoveIndex = gamefile.boardsim.moves.length - 1;
			if (!moveHistoryLegalMoves.has(latestMoveIndex)) {
				sendPositionToEngine(true);
			}
		}
	}
}

/** Renders a debug preview of the engine's generated legal moves for the current position. */
function render(): void {
	if (!inEngineGame) return;
	if (!move_gen_debug) return;

	// Get the moves for the current position
	const gamefile = gameslot.getGamefile()!;
	const currentMoveIndex = gamefile.boardsim.state.local.moveIndex;
	const currentMoves = moveHistoryLegalMoves.get(currentMoveIndex) || [];

	// Map moves to squares
	const coordsKeys: CoordsKey[] = currentMoves.flatMap((moveStr: string) => {
		const [_from, to] = moveStr.split('>');
		return [to]; // We only care about the destination square for highlighting
	}) as CoordsKey[]; // ["x,y", ...]

	// Early exit if no drawn-squares to draw
	if (coordsKeys.length === 0) return;

	const coords: Coords[] = coordsKeys.map((s) => coordutil.getCoordsFromKey(s)); // [[x,y], ...]

	// If we're zoomed out, then the size of the moves are constant.
	const u_size = boardpos.areZoomedOut()
		? snapping.getEntityWidthWorld()
		: boardpos.getBoardScaleAsNumber();

	const color = drawsquares.PRESET_SQUARE_COLOR;

	// Render legal move squares
	squarerendering.genModel(coords, color).render(undefined, undefined, { u_size });
}

// Export ---------------------------------------------------------------------------------

export { engineWorldBorderDict, engineDefaultTimeLimitPerMoveMillisDict };

export default {
	areInEngineGame,
	getOurColor,
	isItOurTurn,
	getCurrentEngine,
	initEngineGame,
	closeEngineGame,
	areWeColor,
	onMovePlayed,
	onGameConclude,
	toggleDebug,
	render,
};

export type { EngineConfig, validEngineName };
