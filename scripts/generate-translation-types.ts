// scripts/generate-translation-types.ts

/**
 * Generates TypeScript types from the English translation TOML file.
 * Creates two type structures:
 * 1. Flat dot-notation union type for server-side i18next
 * 2. Nested object type for client-side property access
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'node:url';
import { parse, TomlTable } from 'smol-toml';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const translationFile = path.join(__dirname, '../translation/en-US.toml');
const outputFile = path.join(__dirname, '../src/types/translations.ts');

/**
 * Recursively generates all dot-notation paths for a nested object.
 * @param obj - The object to traverse
 * @param prefix - The current path prefix
 * @returns Array of dot-notation paths
 */
function generateDotPaths(obj: TomlTable | any, prefix = ''): string[] {
	const paths: string[] = [];

	for (const [key, value] of Object.entries(obj)) {
		const path = prefix ? `${prefix}.${key}` : key;

		if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
			// Recursively traverse nested objects
			paths.push(...generateDotPaths(value, path));
		} else {
			// Leaf node - add the path
			paths.push(path);
		}
	}

	return paths;
}

/**
 * Generates a TypeScript interface from a nested object structure.
 * @param obj - The object to convert to a type
 * @param indentLevel - Current indentation level
 * @returns TypeScript interface string
 */
function generateNestedType(obj: TomlTable | any, indentLevel = 1): string {
	const indent = '\t'.repeat(indentLevel);
	const lines: string[] = [];

	for (const [key, value] of Object.entries(obj)) {
		// Handle keys with hyphens or other special characters
		const safeKey = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;

		if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
			// Nested object - add index signature for dynamic access
			lines.push(`${indent}${safeKey}: {`);
			lines.push(generateNestedType(value, indentLevel + 1));
			lines.push(`${indent}\t[key: string]: any;`);
			lines.push(`${indent}};`);
		} else if (Array.isArray(value)) {
			// Array type
			lines.push(`${indent}${safeKey}: string[];`);
		} else {
			// Primitive type
			lines.push(`${indent}${safeKey}: string;`);
		}
	}

	return lines.join('\n');
}

/**
 * Main function to generate translation types.
 */
function generateTypes(): void {
	const tomlContent = fs.readFileSync(translationFile, 'utf-8');
	const parsed = parse(tomlContent);
	const dotPaths = generateDotPaths(parsed);
	const nestedType = generateNestedType(parsed);

	// Create the output TypeScript file
	const output = `// This file is auto-generated by scripts/generate-translation-types.ts
// Do not edit manually!

/**
 * Flat dot-notation union type for server-side i18next.
 * Use with i18next.t() function.
 * @example
 * i18next.t("play.javascript.termination.checkmate")
 */
export type TranslationKeys =${dotPaths.map((p) => `\n\t| '${p}'`).join('')};

/**
 * Nested object type for client-side translation access.
 * Represents the full structure of the translation object.
 */
export interface TranslationsObject {
${nestedType}
}
`;

	fs.writeFileSync(outputFile, output, 'utf-8');

	console.log(
		`[generate-translation-types] Generated translation types (${dotPaths.length} keys).`,
	);
}

// Run the generator
try {
	generateTypes();
} catch (error) {
	console.error('Error generating translation types:', error);
	process.exit(1);
}
